// Code generated by go2go; DO NOT EDIT.


//line /home/tobias/Development/go/peds/go2go/src/peds/map_test.go2:1
package peds

//line /home/tobias/Development/go/peds/go2go/src/peds/map_test.go2:1
import (
//line /home/tobias/Development/go/peds/go2go/src/peds/map_test.go2:1
 "fmt"
//line /home/tobias/Development/go/peds/go2go/src/peds/map_test.go2:1
 "math"
//line /home/tobias/Development/go/peds/go2go/src/peds/map_test.go2:1
 "runtime"
//line /home/tobias/Development/go/peds/go2go/src/peds/map_test.go2:1
 "strings"
//line /home/tobias/Development/go/peds/go2go/src/peds/map_test.go2:1
 "testing"
//line /home/tobias/Development/go/peds/go2go/src/peds/map_test.go2:1
 "unsafe"
//line /home/tobias/Development/go/peds/go2go/src/peds/map_test.go2:1
)

//line /home/tobias/Development/go/peds/go2go/src/peds/map_test.go2:8
func TestLenOfNewMap(t *testing.T) {
	m := instantiate୦୦NewMap୦string୦int()
	assertEqual(t, 0, m.Len())

	m2 := instantiate୦୦NewMap୦string୦int(instantiate୦୦MapItem୦string୦int{Key: "a", Value: 1})
	assertEqual(t, 1, m2.Len())

	m3 := instantiate୦୦NewMap୦string୦int(instantiate୦୦MapItem୦string୦int{Key: "a", Value: 1}, instantiate୦୦MapItem୦string୦int{Key: "b", Value: 2})
	assertEqual(t, 2, m3.Len())
}

func TestLoadAndStore(t *testing.T) {
	m := instantiate୦୦NewMap୦string୦int()

	m2 := m.Store("a", 1)
	assertEqual(t, 0, m.Len())
	assertEqual(t, 1, m2.Len())

	v, ok := m.Load("a")
	assertEqual(t, 0, v)
	assertEqualBool(t, false, ok)

	v, ok = m2.Load("a")
	assertEqual(t, 1, v)
	assertEqualBool(t, true, ok)
}

func TestLoadAndStoreIntKey(t *testing.T) {
	m := instantiate୦୦NewMap୦int୦string()

	m2 := m.Store(1, "")
	v, _ := m.Load(2)
	assertEqualString(t, "", v)

	v, _ = m2.Load(1)
	assertEqualString(t, "", v)
}

func TestLoadAndDeleteExistingItem(t *testing.T) {
	m := instantiate୦୦NewMap୦string୦int()
	m2 := m.Store("a", 1)
	m3 := m.Delete("a")

	assertEqual(t, 0, m3.Len())
	assertEqual(t, 1, m2.Len())

	v, ok := m2.Load("a")
	assertEqualBool(t, true, ok)
	assertEqual(t, 1, v)

	v, ok = m3.Load("a")
	assertEqualBool(t, false, ok)
	assertEqual(t, 0, v)
}

func TestLoadAndDeleteNonExistingItem(t *testing.T) {
	m := instantiate୦୦NewMap୦string୦int()
	m2 := m.Store("a", 1)
	m3 := m2.Delete("b")

	assertEqual(t, 1, m3.Len())
	assertEqual(t, 1, m2.Len())

	v, ok := m2.Load("a")
	assertEqualBool(t, true, ok)
	assertEqual(t, 1, v)

	if m2 != m3 {
		t.Errorf("m2 and m3 are not the same object: %p != %p", m2, m3)
	}
}

func TestRangeAllItems(t *testing.T) {
	m := instantiate୦୦NewMap୦string୦int(instantiate୦୦MapItem୦string୦int{Key: "a", Value: 1}, instantiate୦୦MapItem୦string୦int{Key: "b", Value: 2}, instantiate୦୦MapItem୦string୦int{Key: "c", Value: 3})
	sum := 0
	m.Range(func(key string, value int) bool {
		sum += value
		return true
	})
	assertEqual(t, 6, sum)
}

func TestRangeStopOnKey(t *testing.T) {
	m := instantiate୦୦NewMap୦string୦int(instantiate୦୦MapItem୦string୦int{Key: "a", Value: 1}, instantiate୦୦MapItem୦string୦int{Key: "b", Value: 2}, instantiate୦୦MapItem୦string୦int{Key: "c", Value: 3})
	count := 0
	m.Range(func(key string, value int) bool {
		if key == "c" || key == "b" {
			return false
		}

		count++
		return true
	})

	if count > 1 {
		t.Errorf("Did not expect count to be more than 1")
	}
}

func TestLargeInsertLookupDelete(t *testing.T) {

//line /home/tobias/Development/go/peds/go2go/src/peds/map_test.go2:110
 size := 500
	m := instantiate୦୦NewMap୦string୦int()
	for j := 0; j < size; j++ {
		m = m.Store(fmt.Sprintf("%d", j), j)
	}

	for j := 0; j < size; j++ {
		v, ok := m.Load(fmt.Sprintf("%d", j))
		assertEqualBool(t, true, ok)
		assertEqual(t, v, j)
	}

	for j := 0; j < size; j++ {
		key := fmt.Sprintf("%d", j)
		m = m.Delete(key)
		assertEqual(t, size-j-1, m.Len())
		_, ok := m.Load(key)
		assertEqualBool(t, false, ok)
	}
}

func TestFromToNativeMap(t *testing.T) {
	input := map[string]int{
		"a": 1,
		"b": 2,
		"c": 3}
	m := instantiate୦୦NewMapFromNativeMap୦string୦int(input)
	output := m.ToNativeMap()
	assertEqual(t, len(input), len(output))
	for key, value := range input {
		assertEqual(t, value, output[key])
	}
}
//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:86
func instantiate୦୦NewMap୦string୦int(items ...instantiate୦୦MapItem୦string୦int,) *instantiate୦୦Map୦string୦int {
	return instantiate୦୦newMap୦string୦int(items)
}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:88
type instantiate୦୦MapItem୦string୦int struct {
//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:13
 Key string

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:14
 Value int
}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:86
func instantiate୦୦NewMap୦int୦string(items ...instantiate୦୦MapItem୦int୦string,) *instantiate୦୦Map୦int୦string {
	return instantiate୦୦newMap୦int୦string(items)
}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:91
func instantiate୦୦NewMapFromNativeMap୦string୦int(m map[string]int) *instantiate୦୦Map୦string୦int {
	buckets := instantiate୦୦newPrivateItemBuckets୦string୦int(len(m))
	for key, value := range m {
		buckets.AddItem(instantiate୦୦MapItem୦string୦int{Key: key, Value: value})
	}

	return &instantiate୦୦Map୦string୦int{backingVector: instantiate୦୦NewVector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9(buckets.buckets...), len: buckets.length}
}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:98
type instantiate୦୦Map୦string୦int struct {
//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:43
 backingVector *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9
									len           int
}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:101
func (m *instantiate୦୦Map୦string୦int,) Len() int {
	return int(m.len)
}

func (m *instantiate୦୦Map୦string୦int,) pos(key string,

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:105
) int {
	return int(uint64(genericHash(key)) % uint64(m.backingVector.Len()))
}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:110
func (m *instantiate୦୦Map୦string୦int,) Load(key string,

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:110
) (value int,

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:110
 ok bool) {
	bucket := m.backingVector.Get(m.pos(key))
	if bucket != nil {
		for _, item := range bucket {
			if item.Key == key {
				return item.Value, true
			}
		}
	}

									var zeroValue int

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:121
 return zeroValue, false
}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:125
func (m *instantiate୦୦Map୦string୦int,) Store(key string,

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:125
 value int,

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:125
) *instantiate୦୦Map୦string୦int {

	if m.Len() >= m.backingVector.Len()*int(upperMapLoadFactor) {
		buckets := instantiate୦୦newPrivateItemBuckets୦string୦int(m.Len() + 1)
		buckets.AddItemsFromMap(m)
		buckets.AddItem(instantiate୦୦MapItem୦string୦int{Key: key, Value: value})
		return &instantiate୦୦Map୦string୦int{backingVector: instantiate୦୦NewVector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9(buckets.buckets...), len: buckets.length}
	}

	pos := m.pos(key)
	bucket := m.backingVector.Get(pos)
	if bucket != nil {
		for ix, item := range bucket {
			if item.Key == key {

				newBucket := make(instantiate୦୦privateItemBucket୦string୦int, len(bucket))
				copy(newBucket, bucket)
				newBucket[ix] = instantiate୦୦MapItem୦string୦int{Key: key, Value: value}
				return &instantiate୦୦Map୦string୦int{backingVector: m.backingVector.Set(pos, newBucket), len: m.len}
			}
		}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:148
  newBucket := make(instantiate୦୦privateItemBucket୦string୦int, len(bucket), len(bucket)+1)
		copy(newBucket, bucket)
		newBucket = append(newBucket, instantiate୦୦MapItem୦string୦int{Key: key, Value: value})
		return &instantiate୦୦Map୦string୦int{backingVector: m.backingVector.Set(pos, newBucket), len: m.len + 1}
	}

	item := instantiate୦୦MapItem୦string୦int{Key: key, Value: value}
	newBucket := instantiate୦୦privateItemBucket୦string୦int{item}
	return &instantiate୦୦Map୦string୦int{backingVector: m.backingVector.Set(pos, newBucket), len: m.len + 1}
}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:160
func (m *instantiate୦୦Map୦string୦int,) Delete(key string,

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:160
) *instantiate୦୦Map୦string୦int {
	pos := m.pos(key)
	bucket := m.backingVector.Get(pos)
	if bucket != nil {
		newBucket := make(instantiate୦୦privateItemBucket୦string୦int, 0)
		for _, item := range bucket {
			if item.Key != key {
				newBucket = append(newBucket, item)
			}
		}

		removedItemCount := len(bucket) - len(newBucket)
		if removedItemCount == 0 {
			return m
		}

		if len(newBucket) == 0 {
			newBucket = nil
		}

		newMap := &instantiate୦୦Map୦string୦int{backingVector: m.backingVector.Set(pos, newBucket), len: m.len - removedItemCount}
		if newMap.backingVector.Len() > 1 && newMap.Len() < newMap.backingVector.Len()*int(lowerMapLoadFactor) {

			buckets := instantiate୦୦newPrivateItemBuckets୦string୦int(newMap.Len())
			buckets.AddItemsFromMap(newMap)
			return &instantiate୦୦Map୦string୦int{backingVector: instantiate୦୦NewVector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9(buckets.buckets...), len: buckets.length}
		}

		return newMap
	}

	return m
}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:196
func (m *instantiate୦୦Map୦string୦int,) Range(f func(string, int,

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:196
) bool) {
	m.backingVector.Range(func(bucket instantiate୦୦privateItemBucket୦string୦int,) bool {
		for _, item := range bucket {
			if !f(item.Key, item.Value) {
				return false
			}
		}
		return true
	})
}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:208
func (m *instantiate୦୦Map୦string୦int,) ToNativeMap() map[string]int {
	result := make(map[string]int,
//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:209
 )
									m.Range(func(key string,

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:210
  value int,

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:210
 ) bool { result[key] = value; return true })

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:215
 return result
}
//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:77
func instantiate୦୦newMap୦string୦int(items []instantiate୦୦MapItem୦string୦int,) *instantiate୦୦Map୦string୦int {
	buckets := instantiate୦୦newPrivateItemBuckets୦string୦int(len(items))
	for _, item := range items {
		buckets.AddItem(item)
	}
	return &instantiate୦୦Map୦string୦int{backingVector: instantiate୦୦NewVector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9(buckets.buckets...), len: buckets.length}
}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:83
type instantiate୦୦MapItem୦int୦string struct {
//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:13
 Key   int
									Value string
}
//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:15
type instantiate୦୦Map୦int୦string struct {
//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:43
 backingVector *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9
	len int
}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:101
func (m *instantiate୦୦Map୦int୦string,) Len() int {
	return int(m.len)
}

func (m *instantiate୦୦Map୦int୦string,) pos(key int,

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:105
) int {
	return int(uint64(genericHash(key)) % uint64(m.backingVector.Len()))
}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:110
func (m *instantiate୦୦Map୦int୦string,) Load(key int,

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:110
) (value string,

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:110
 ok bool) {
	bucket := m.backingVector.Get(m.pos(key))
	if bucket != nil {
		for _, item := range bucket {
			if item.Key == key {
				return item.Value, true
			}
		}
	}

									var zeroValue string

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:121
 return zeroValue, false
}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:125
func (m *instantiate୦୦Map୦int୦string,) Store(key int,

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:125
 value string,

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:125
) *instantiate୦୦Map୦int୦string {

	if m.Len() >= m.backingVector.Len()*int(upperMapLoadFactor) {
		buckets := instantiate୦୦newPrivateItemBuckets୦int୦string(m.Len() + 1)
		buckets.AddItemsFromMap(m)
		buckets.AddItem(instantiate୦୦MapItem୦int୦string{Key: key, Value: value})
		return &instantiate୦୦Map୦int୦string{backingVector: instantiate୦୦NewVector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9(buckets.buckets...), len: buckets.length}
	}

	pos := m.pos(key)
	bucket := m.backingVector.Get(pos)
	if bucket != nil {
		for ix, item := range bucket {
			if item.Key == key {

				newBucket := make(instantiate୦୦privateItemBucket୦int୦string, len(bucket))
				copy(newBucket, bucket)
				newBucket[ix] = instantiate୦୦MapItem୦int୦string{Key: key, Value: value}
				return &instantiate୦୦Map୦int୦string{backingVector: m.backingVector.Set(pos, newBucket), len: m.len}
			}
		}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:148
  newBucket := make(instantiate୦୦privateItemBucket୦int୦string, len(bucket), len(bucket)+1)
		copy(newBucket, bucket)
		newBucket = append(newBucket, instantiate୦୦MapItem୦int୦string{Key: key, Value: value})
		return &instantiate୦୦Map୦int୦string{backingVector: m.backingVector.Set(pos, newBucket), len: m.len + 1}
	}

	item := instantiate୦୦MapItem୦int୦string{Key: key, Value: value}
	newBucket := instantiate୦୦privateItemBucket୦int୦string{item}
	return &instantiate୦୦Map୦int୦string{backingVector: m.backingVector.Set(pos, newBucket), len: m.len + 1}
}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:160
func (m *instantiate୦୦Map୦int୦string,) Delete(key int,

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:160
) *instantiate୦୦Map୦int୦string {
	pos := m.pos(key)
	bucket := m.backingVector.Get(pos)
	if bucket != nil {
		newBucket := make(instantiate୦୦privateItemBucket୦int୦string, 0)
		for _, item := range bucket {
			if item.Key != key {
				newBucket = append(newBucket, item)
			}
		}

		removedItemCount := len(bucket) - len(newBucket)
		if removedItemCount == 0 {
			return m
		}

		if len(newBucket) == 0 {
			newBucket = nil
		}

		newMap := &instantiate୦୦Map୦int୦string{backingVector: m.backingVector.Set(pos, newBucket), len: m.len - removedItemCount}
		if newMap.backingVector.Len() > 1 && newMap.Len() < newMap.backingVector.Len()*int(lowerMapLoadFactor) {

			buckets := instantiate୦୦newPrivateItemBuckets୦int୦string(newMap.Len())
			buckets.AddItemsFromMap(newMap)
			return &instantiate୦୦Map୦int୦string{backingVector: instantiate୦୦NewVector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9(buckets.buckets...), len: buckets.length}
		}

		return newMap
	}

	return m
}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:196
func (m *instantiate୦୦Map୦int୦string,) Range(f func(int, string,

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:196
) bool) {
	m.backingVector.Range(func(bucket instantiate୦୦privateItemBucket୦int୦string,) bool {
		for _, item := range bucket {
			if !f(item.Key, item.Value) {
				return false
			}
		}
		return true
	})
}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:208
func (m *instantiate୦୦Map୦int୦string,) ToNativeMap() map[int]string {
	result := make(map[int]string,
//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:209
 )
									m.Range(func(key int,

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:210
  value string,

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:210
 ) bool { result[key] = value; return true })

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:215
 return result
}
//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:77
func instantiate୦୦newMap୦int୦string(items []instantiate୦୦MapItem୦int୦string,) *instantiate୦୦Map୦int୦string {
	buckets := instantiate୦୦newPrivateItemBuckets୦int୦string(len(items))
	for _, item := range items {
		buckets.AddItem(item)
	}
	return &instantiate୦୦Map୦int୦string{backingVector: instantiate୦୦NewVector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9(buckets.buckets...), len: buckets.length}
}
//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:34
func instantiate୦୦newPrivateItemBuckets୦string୦int(itemCount int) *instantiate୦୦privateItemBuckets୦string୦int {
									size := int(float64(itemCount)/initialMapLoadFactor) + 1

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:38
 buckets := make([](instantiate୦୦privateItemBucket୦string୦int), size)
	return &instantiate୦୦privateItemBuckets୦string୦int{buckets: buckets}
}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:40
type instantiate୦୦privateItemBucket୦string୦int []instantiate୦୦MapItem୦string୦int

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:34
func instantiate୦୦NewVector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9(items ...instantiate୦୦privateItemBucket୦string୦int,) *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9 {

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:37
 tail := make([]instantiate୦୦privateItemBucket୦string୦int, 0)
	v := &instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9{root: emptyCommonNode, shift: shiftSize, tail: tail}
	return v.Append(items...)
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:40
type instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9 struct {
//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:27
 tail  []instantiate୦୦privateItemBucket୦string୦int
										root  commonNode
										len   uint
										shift uint
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:43
func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9,) Append(item ...instantiate୦୦privateItemBucket୦string୦int,) *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9 {
	result := v
	itemLen := uint(len(item))
	for insertOffset := uint(0); insertOffset < itemLen; {
		tailLen := result.len - result.tailOffset()
		tailFree := nodeSize - tailLen
		if tailFree == 0 {
			result = result.pushLeafNode(result.tail)
			result.tail = make([]instantiate୦୦privateItemBucket୦string୦int, 0)
			tailFree = nodeSize
			tailLen = 0
		}

		batchLen := uintMin(itemLen-insertOffset, tailFree)
		newTail := make([]instantiate୦୦privateItemBucket୦string୦int, 0, tailLen+batchLen)
		newTail = append(newTail, result.tail...)
		newTail = append(newTail, item[insertOffset:insertOffset+batchLen]...)
		result = &instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9{root: result.root, tail: newTail, len: result.len + batchLen, shift: result.shift}
		insertOffset += batchLen
	}

	return result
}

func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9,) tailOffset() uint {
	if v.len < nodeSize {
		return 0
	}

	return ((v.len - 1) >> shiftSize) << shiftSize
}

func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9,) pushLeafNode(node []instantiate୦୦privateItemBucket୦string୦int,) *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9 {
										var newRoot commonNode
										newShift := v.shift

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:80
 if (v.len >> shiftSize) > (1 << v.shift) {
		newNode := newPath(v.shift, node)
		newRoot = commonNode([]commonNode{v.root, newNode})
		newShift = v.shift + shiftSize
	} else {
		newRoot = v.pushTail(v.shift, v.root, node)
	}

	return &instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9{root: newRoot, tail: v.tail, len: v.len, shift: newShift}
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:99
func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9,) pushTail(level uint, parent commonNode, tailNode []instantiate୦୦privateItemBucket୦string୦int,) commonNode {
	subIdx := ((v.len - 1) >> level) & shiftBitMask
	parentNode := parent.([]commonNode)
	ret := make([]commonNode, subIdx+1)
	copy(ret, parentNode)
	var nodeToInsert commonNode

	if level == shiftSize {
		nodeToInsert = tailNode
	} else if subIdx < uint(len(parentNode)) {
		nodeToInsert = v.pushTail(level-shiftSize, parentNode[subIdx], tailNode)
	} else {
		nodeToInsert = newPath(level-shiftSize, tailNode)
	}

	ret[subIdx] = nodeToInsert
	return ret
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:119
func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9,) Len() int {
	return int(v.len)
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:124
func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9,) Get(i int) instantiate୦୦privateItemBucket୦string୦int {
	if i < 0 || uint(i) >= v.len {
		panic("Index out of bounds")
	}

	return v.sliceFor(uint(i))[i&shiftBitMask]
}

func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9,) sliceFor(i uint) []instantiate୦୦privateItemBucket୦string୦int {
	if i >= v.tailOffset() {
		return v.tail
	}

	node := v.root
	for level := v.shift; level > 0; level -= shiftSize {
		node = node.([]commonNode)[(i>>level)&shiftBitMask]
	}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:144
 return node.([]instantiate୦୦privateItemBucket୦string୦int)
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:149
func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9,) Set(i int, item instantiate୦୦privateItemBucket୦string୦int,) *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9 {
	if i < 0 || uint(i) >= v.len {
		panic("Index out of bounds")
	}

	if uint(i) >= v.tailOffset() {
		newTail := make([]instantiate୦୦privateItemBucket୦string୦int, len(v.tail))
		copy(newTail, v.tail)
		newTail[i&shiftBitMask] = item
		return &instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9{root: v.root, tail: newTail, len: v.len, shift: v.shift}
	}

	return &instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9{root: v.doAssoc(v.shift, v.root, uint(i), item), tail: v.tail, len: v.len, shift: v.shift}
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:165
func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9,) doAssoc(level uint, node commonNode, i uint, item instantiate୦୦privateItemBucket୦string୦int,) commonNode {
	if level == 0 {
		ret := make([]instantiate୦୦privateItemBucket୦string୦int, nodeSize)
		copy(ret, node.([]instantiate୦୦privateItemBucket୦string୦int))
		ret[i&shiftBitMask] = item
		return ret
	}

	ret := make([]commonNode, nodeSize)
	copy(ret, node.([]commonNode))
	subidx := (i >> level) & shiftBitMask
	ret[subidx] = v.doAssoc(level-shiftSize, ret[subidx], i, item)
	return ret
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:182
func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9,) Range(f func(instantiate୦୦privateItemBucket୦string୦int,) bool) {
	var currentNode []instantiate୦୦privateItemBucket୦string୦int
	for i := uint(0); i < v.len; i++ {
		if i&shiftBitMask == 0 {
			currentNode = v.sliceFor(i)
		}

		if !f(currentNode[i&shiftBitMask]) {
			return
		}
	}
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:196
func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9,) Slice(start, stop int) *instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8string୮3୮0int୮9 {
	assertSliceOk(start, stop, v.Len())
	return &instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8string୮3୮0int୮9{vector: v, start: start, stop: stop}
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:203
func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9,) ToNativeSlice() []instantiate୦୦privateItemBucket୦string୦int {
	result := make([]instantiate୦୦privateItemBucket୦string୦int, 0, v.len)
	for i := uint(0); i < v.len; i += nodeSize {
		result = append(result, v.sliceFor(i)...)
	}

	return result
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:210
type instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9 struct {
//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:27
 tail  []instantiate୦୦privateItemBucket୦int୦string
										root  commonNode
										len   uint
										shift uint
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:43
func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9,) Append(item ...instantiate୦୦privateItemBucket୦int୦string,) *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9 {
	result := v
	itemLen := uint(len(item))
	for insertOffset := uint(0); insertOffset < itemLen; {
		tailLen := result.len - result.tailOffset()
		tailFree := nodeSize - tailLen
		if tailFree == 0 {
			result = result.pushLeafNode(result.tail)
			result.tail = make([]instantiate୦୦privateItemBucket୦int୦string, 0)
			tailFree = nodeSize
			tailLen = 0
		}

		batchLen := uintMin(itemLen-insertOffset, tailFree)
		newTail := make([]instantiate୦୦privateItemBucket୦int୦string, 0, tailLen+batchLen)
		newTail = append(newTail, result.tail...)
		newTail = append(newTail, item[insertOffset:insertOffset+batchLen]...)
		result = &instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9{root: result.root, tail: newTail, len: result.len + batchLen, shift: result.shift}
		insertOffset += batchLen
	}

	return result
}

func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9,) tailOffset() uint {
	if v.len < nodeSize {
		return 0
	}

	return ((v.len - 1) >> shiftSize) << shiftSize
}

func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9,) pushLeafNode(node []instantiate୦୦privateItemBucket୦int୦string,) *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9 {
										var newRoot commonNode
										newShift := v.shift

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:80
 if (v.len >> shiftSize) > (1 << v.shift) {
		newNode := newPath(v.shift, node)
		newRoot = commonNode([]commonNode{v.root, newNode})
		newShift = v.shift + shiftSize
	} else {
		newRoot = v.pushTail(v.shift, v.root, node)
	}

	return &instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9{root: newRoot, tail: v.tail, len: v.len, shift: newShift}
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:99
func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9,) pushTail(level uint, parent commonNode, tailNode []instantiate୦୦privateItemBucket୦int୦string,) commonNode {
	subIdx := ((v.len - 1) >> level) & shiftBitMask
	parentNode := parent.([]commonNode)
	ret := make([]commonNode, subIdx+1)
	copy(ret, parentNode)
	var nodeToInsert commonNode

	if level == shiftSize {
		nodeToInsert = tailNode
	} else if subIdx < uint(len(parentNode)) {
		nodeToInsert = v.pushTail(level-shiftSize, parentNode[subIdx], tailNode)
	} else {
		nodeToInsert = newPath(level-shiftSize, tailNode)
	}

	ret[subIdx] = nodeToInsert
	return ret
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:119
func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9,) Len() int {
	return int(v.len)
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:124
func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9,) Get(i int) instantiate୦୦privateItemBucket୦int୦string {
	if i < 0 || uint(i) >= v.len {
		panic("Index out of bounds")
	}

	return v.sliceFor(uint(i))[i&shiftBitMask]
}

func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9,) sliceFor(i uint) []instantiate୦୦privateItemBucket୦int୦string {
	if i >= v.tailOffset() {
		return v.tail
	}

	node := v.root
	for level := v.shift; level > 0; level -= shiftSize {
		node = node.([]commonNode)[(i>>level)&shiftBitMask]
	}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:144
 return node.([]instantiate୦୦privateItemBucket୦int୦string)
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:149
func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9,) Set(i int, item instantiate୦୦privateItemBucket୦int୦string,) *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9 {
	if i < 0 || uint(i) >= v.len {
		panic("Index out of bounds")
	}

	if uint(i) >= v.tailOffset() {
		newTail := make([]instantiate୦୦privateItemBucket୦int୦string, len(v.tail))
		copy(newTail, v.tail)
		newTail[i&shiftBitMask] = item
		return &instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9{root: v.root, tail: newTail, len: v.len, shift: v.shift}
	}

	return &instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9{root: v.doAssoc(v.shift, v.root, uint(i), item), tail: v.tail, len: v.len, shift: v.shift}
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:165
func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9,) doAssoc(level uint, node commonNode, i uint, item instantiate୦୦privateItemBucket୦int୦string,) commonNode {
	if level == 0 {
		ret := make([]instantiate୦୦privateItemBucket୦int୦string, nodeSize)
		copy(ret, node.([]instantiate୦୦privateItemBucket୦int୦string))
		ret[i&shiftBitMask] = item
		return ret
	}

	ret := make([]commonNode, nodeSize)
	copy(ret, node.([]commonNode))
	subidx := (i >> level) & shiftBitMask
	ret[subidx] = v.doAssoc(level-shiftSize, ret[subidx], i, item)
	return ret
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:182
func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9,) Range(f func(instantiate୦୦privateItemBucket୦int୦string,) bool) {
	var currentNode []instantiate୦୦privateItemBucket୦int୦string
	for i := uint(0); i < v.len; i++ {
		if i&shiftBitMask == 0 {
			currentNode = v.sliceFor(i)
		}

		if !f(currentNode[i&shiftBitMask]) {
			return
		}
	}
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:196
func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9,) Slice(start, stop int) *instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8int୮3୮0string୮9 {
	assertSliceOk(start, stop, v.Len())
	return &instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8int୮3୮0string୮9{vector: v, start: start, stop: stop}
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:203
func (v *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9,) ToNativeSlice() []instantiate୦୦privateItemBucket୦int୦string {
	result := make([]instantiate୦୦privateItemBucket୦int୦string, 0, v.len)
	for i := uint(0); i < v.len; i += nodeSize {
		result = append(result, v.sliceFor(i)...)
	}

	return result
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:210
type instantiate୦୦privateItemBucket୦int୦string []instantiate୦୦MapItem୦int୦string

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:34
func instantiate୦୦newPrivateItemBuckets୦int୦string(itemCount int) *instantiate୦୦privateItemBuckets୦int୦string {
									size := int(float64(itemCount)/initialMapLoadFactor) + 1

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:38
 buckets := make([](instantiate୦୦privateItemBucket୦int୦string), size)
	return &instantiate୦୦privateItemBuckets୦int୦string{buckets: buckets}
}
//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:34
func instantiate୦୦NewVector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9(items ...instantiate୦୦privateItemBucket୦int୦string,) *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9 {

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:37
 tail := make([]instantiate୦୦privateItemBucket୦int୦string, 0)
	v := &instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9{root: emptyCommonNode, shift: shiftSize, tail: tail}
	return v.Append(items...)
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:40
type instantiate୦୦privateItemBuckets୦string୦int struct {
//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:30
 buckets []instantiate୦୦privateItemBucket୦string୦int
									length  int
}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:47
func (b *instantiate୦୦privateItemBuckets୦string୦int,) AddItem(item instantiate୦୦MapItem୦string୦int,) {
	ix := int(uint64(genericHash(item.Key)) % uint64(len(b.buckets)))
	bucket := b.buckets[ix]
	if bucket != nil {

		for keyIx, bItem := range bucket {
			if item.Key == bItem.Key {
				bucket[keyIx] = item
				return
			}
		}

		b.buckets[ix] = append(bucket, instantiate୦୦MapItem୦string୦int{Key: item.Key, Value: item.Value})
		b.length++
	} else {
		bucket := make(instantiate୦୦privateItemBucket୦string୦int, 0, int(math.Max(initialMapLoadFactor, 1.0)))
		b.buckets[ix] = append(bucket, item)
		b.length++
	}
}

func (b *instantiate୦୦privateItemBuckets୦string୦int,) AddItemsFromMap(m *instantiate୦୦Map୦string୦int,) {
	m.backingVector.Range(func(bucket instantiate୦୦privateItemBucket୦string୦int,) bool {
		for _, item := range bucket {
			b.AddItem(item)
		}
		return true
	})
}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:75
type instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8string୮3୮0int୮9 struct {
//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:233
 vector *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8string୮3୮0int୮9
	start, stop int
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:243
func (s *instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8string୮3୮0int୮9,) Len() int {
	return s.stop - s.start
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:248
func (s *instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8string୮3୮0int୮9,) Get(i int) instantiate୦୦privateItemBucket୦string୦int {
	if i < 0 || s.start+i >= s.stop {
		panic("Index out of bounds")
	}

	return s.vector.Get(s.start + i)
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:257
func (s *instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8string୮3୮0int୮9,) Set(i int, item instantiate୦୦privateItemBucket୦string୦int,) *instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8string୮3୮0int୮9 {
	if i < 0 || s.start+i >= s.stop {
		panic("Index out of bounds")
	}

	return s.vector.Set(s.start+i, item).Slice(s.start, s.stop)
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:266
func (s *instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8string୮3୮0int୮9,) Append(items ...instantiate୦୦privateItemBucket୦string୦int,) *instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8string୮3୮0int୮9 {
										newSlice := instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8string୮3୮0int୮9{vector: s.vector, start: s.start, stop: s.stop + len(items)}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:272
 itemPos := 0
	for ; s.stop+itemPos < s.vector.Len() && itemPos < len(items); itemPos++ {
		newSlice.vector = newSlice.vector.Set(s.stop+itemPos, items[itemPos])
	}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:278
 newSlice.vector = newSlice.vector.Append(items[itemPos:]...)
	return &newSlice
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:283
func (s *instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8string୮3୮0int୮9,) Slice(start, stop int) *instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8string୮3୮0int୮9 {
	assertSliceOk(start, stop, s.stop-s.start)
	return &instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8string୮3୮0int୮9{vector: s.vector, start: s.start + start, stop: s.start + stop}
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:290
func (s *instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8string୮3୮0int୮9,) Range(f func(instantiate୦୦privateItemBucket୦string୦int,) bool) {
	var currentNode []instantiate୦୦privateItemBucket୦string୦int
	for i := uint(s.start); i < uint(s.stop); i++ {
		if i&shiftBitMask == 0 || i == uint(s.start) {
			currentNode = s.vector.sliceFor(uint(i))
		}

		if !f(currentNode[i&shiftBitMask]) {
			return
		}
	}
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:301
type instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8int୮3୮0string୮9 struct {
//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:233
 vector      *instantiate୦୦Vector୦peds୮aprivateItemBucket୮8int୮3୮0string୮9
										start, stop int
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:243
func (s *instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8int୮3୮0string୮9,) Len() int {
	return s.stop - s.start
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:248
func (s *instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8int୮3୮0string୮9,) Get(i int) instantiate୦୦privateItemBucket୦int୦string {
	if i < 0 || s.start+i >= s.stop {
		panic("Index out of bounds")
	}

	return s.vector.Get(s.start + i)
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:257
func (s *instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8int୮3୮0string୮9,) Set(i int, item instantiate୦୦privateItemBucket୦int୦string,) *instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8int୮3୮0string୮9 {
	if i < 0 || s.start+i >= s.stop {
		panic("Index out of bounds")
	}

	return s.vector.Set(s.start+i, item).Slice(s.start, s.stop)
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:266
func (s *instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8int୮3୮0string୮9,) Append(items ...instantiate୦୦privateItemBucket୦int୦string,) *instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8int୮3୮0string୮9 {
										newSlice := instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8int୮3୮0string୮9{vector: s.vector, start: s.start, stop: s.stop + len(items)}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:272
 itemPos := 0
	for ; s.stop+itemPos < s.vector.Len() && itemPos < len(items); itemPos++ {
		newSlice.vector = newSlice.vector.Set(s.stop+itemPos, items[itemPos])
	}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:278
 newSlice.vector = newSlice.vector.Append(items[itemPos:]...)
	return &newSlice
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:283
func (s *instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8int୮3୮0string୮9,) Slice(start, stop int) *instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8int୮3୮0string୮9 {
	assertSliceOk(start, stop, s.stop-s.start)
	return &instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8int୮3୮0string୮9{vector: s.vector, start: s.start + start, stop: s.start + stop}
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:290
func (s *instantiate୦୦VectorSlice୦peds୮aprivateItemBucket୮8int୮3୮0string୮9,) Range(f func(instantiate୦୦privateItemBucket୦int୦string,) bool) {
	var currentNode []instantiate୦୦privateItemBucket୦int୦string
	for i := uint(s.start); i < uint(s.stop); i++ {
		if i&shiftBitMask == 0 || i == uint(s.start) {
			currentNode = s.vector.sliceFor(uint(i))
		}

		if !f(currentNode[i&shiftBitMask]) {
			return
		}
	}
}

//line /home/tobias/Development/go/peds/go2go/src/peds/containers.go2:301
type instantiate୦୦privateItemBuckets୦int୦string struct {
//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:30
 buckets []instantiate୦୦privateItemBucket୦int୦string
									length  int
}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:47
func (b *instantiate୦୦privateItemBuckets୦int୦string,) AddItem(item instantiate୦୦MapItem୦int୦string,) {
	ix := int(uint64(genericHash(item.Key)) % uint64(len(b.buckets)))
	bucket := b.buckets[ix]
	if bucket != nil {

		for keyIx, bItem := range bucket {
			if item.Key == bItem.Key {
				bucket[keyIx] = item
				return
			}
		}

		b.buckets[ix] = append(bucket, instantiate୦୦MapItem୦int୦string{Key: item.Key, Value: item.Value})
		b.length++
	} else {
		bucket := make(instantiate୦୦privateItemBucket୦int୦string, 0, int(math.Max(initialMapLoadFactor, 1.0)))
		b.buckets[ix] = append(bucket, item)
		b.length++
	}
}

func (b *instantiate୦୦privateItemBuckets୦int୦string,) AddItemsFromMap(m *instantiate୦୦Map୦int୦string,) {
	m.backingVector.Range(func(bucket instantiate୦୦privateItemBucket୦int୦string,) bool {
		for _, item := range bucket {
			b.AddItem(item)
		}
		return true
	})
}

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:75
var _ = fmt.Errorf
//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:75
var _ = math.Abs
//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:75
var _ = runtime.BlockProfile

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:75
type _ strings.Builder

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:75
var _ = testing.AllocsPerRun

//line /home/tobias/Development/go/peds/go2go/src/peds/map.go2:75
type _ unsafe.Pointer
